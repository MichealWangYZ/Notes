# 概念定义

head：句法推导中最基本的成分，直接从词库取出而没有经过别的操作。head大体上可以当成词，但也可以是词根、词缀。“词”的概念是PF定义的。

PF：即phonetic form，语言的外显形式，即被说出来或者写下来的形式

LF：即logical form，语言的语义形式，即基本上和逻辑演算中的表达式类似的形式

specifier，complement

# 基本句法操作

基本框架：几个操作：Merge，Agree，Spellout。
它们配合可以产生Copy，Move，很多时候可以仅仅使用Merge和Move。

## Merge

指导Merge的是句法元素含有的**选择特征**，如动词选择名词等，从而形成二叉树结构。
Merge分为Head Merge和Phrasal Merge两种，它们实际上也没有特别本质的区别。Head Merge可以改变一个句法成分的选择特征，TODO

Move也分成Head Move和Phrasal Move，前者是head to head，后者是argument to argument。

Head Merge在一些理论，如Distributed Morphology中，被废弃了，取而代之的是句法操作完成后的音系学操作。
这里的核心争议在于有没有必要将Head Merge区分出来作为一种单独的操作。

## Agree

有一些人认为Merge发生时Agree随之发生了，且Agree不能远程发生，即Agree只能发生在一个最大投射中，或者甚至只能发生在正在被Merge的两个成分之间。
Agree的具体机制仍有争议，Pesetsky, D. 2013. Russian Case Morphology and the Syntactic Categories. MIT Press.认为Agree过程中发生了Feature assignment，即：
若句法成分$\alpha$主动和一个最大投射$\beta$发生了Agree，那么$\alpha$的特征被全部复制到了$\beta$的**所有**head上（不包括已经被Spellout的部分）。
这就避免了多重Agree。

采用这样的观点可以解释很多观察到的Agree的性质。例如，若head$\alpha$和比它低的head$\beta$有Agree关系，那么必然$\alpha$c-command$\beta$，且$\beta$应该和$\alpha$离得尽可能近。
从feature assignment的角度看，这是因为当$\alpha$和$\beta$Agree时，唯一的可能是$\alpha$和某个包含$\beta$的成分发生了Merge，此时$\alpha$c-command$\gamma$中的每一个成分，自然也c-command$\beta$（如果$\alpha$是中间投射，那么就是$\alpha$的head m-command $\beta$）；
$\alpha$和$\beta$不能相距太远，否则它们可能被phase boundary隔开，就不能发生Agree了。

表面上，feature assignment只允许一个head和另一个成分发生Agree，例如只能够有动词-宾语一致或者动词-主语一致，但通过添加多个功能语类很容易绕过这个限制（如把动词劈裂成动词主干、和主语Agree的一个head以及和宾语Agree的一个head，首先宾语和第三个head发生Merge，从而发生Agree，然后动词主干进入推导，最后第二个head也进入推导，然后主语进入推导，和第二个head发生Agree）
这个就真的只是记号问题了

TODO：概率建模

## Spellout

Spellout操作是指将句法成分完全语音实现，从而让这一部分不再参与未来的句法操作（比如移位），能够触发Spellout的句子成分称为phase。

# 复合句法操作

Merge：工作空间中已有最大投射$\beta$和非最大投射$\alpha$，$\alpha$可以选择$\beta$，则会发生以下步骤：

1. $\mathrm{Merge}(\alpha, \beta)$（或者相反的顺序）将$\alpha$和$\beta$组装成一个成分$[_{\alpha} \; \alpha \; \beta]$（下标$\alpha$表示head是哪一边的，顺序可以颠倒）；
2. 发生Agree，具体来说这包括：
   1. 从$\alpha$到$\beta$的feature assignment，即对每一个$\alpha$中已经定义了而$\beta$中尚未定义的特征$\mathrm{f}$，$\beta$中每一个head的$\mathrm{f}$值都被设定为和$\alpha$相同（对$\beta$内已经发生Spellout的phase不这么做）；
   2. 从$\beta$到$\alpha$的feature assignment，这里可能有一些争议，就是$\alpha$如果是一个中间投射，那么要不要把$\alpha$中的每一个head的未定义特征都赋值，不过大多数情况下$\alpha$都只是单个head（TODO：复合head怎么办？？）
3. 如果$\beta$会触发Spellout，那么把$\beta$除了边缘（即最外层specifier）以外的内容全部Spellout。

phrasal Move：工作空间中已有工作空间中已有最大投射$\beta$和非最大投射$\alpha$，$\alpha$需要首先选择$\beta$，再选择一个成分$\gamma$，$\gamma$是$\beta$的子树，且为最大投射，则会发生以下步骤：

1.

类似地也可以出现phrasal Copy。

需要注意的是语音上直觉性的“成分”未必真的是句法上的成分，因为语音实现是分phase进行的，例如句法上，我们有

[<sub>CP<sub>1</sub></sub> I think [<sub>CP<sub>2</sub></sub> that he is mad ] ]

但是实际上真的语音实现时CP2首先作为一个phase被实现，然后CP1中除了CP2以外的部分被实现，从而在PF中似乎有

[I think] [that he is mad]

这两种划分层次的方法哪一种是正确的？当然，都是正确的。第一种方法是正确的，因为这同时和成分测试以及语义分析一致；第二种方法是正确的，因为可以观察到这样的句子：

I think, hmm, that he is mad

婴儿在语言习得中可能无意将CP1中除了CP2以外的部分识别为一个句法成分，从而导致“I think”演化为句首发语词。

# PF组件

语音实现又是一个非常复杂的领域。这里保存着许多音系操作，除此以外还有一些句法相关的操作。

如果一个成分特意没有被Spellout，那么它就被“删除”了，所以不需要特意加一个Delete操作。

Chain reduction：决定同一个phase中被复制（通过feature assignment）的特征（它们组成一个chain，其中每一个或者位于最低位置，或者c-command另一个）哪些被spellout哪些不被spellout。
通常只spellout最高的一个，但是也不总是这样，比如如果组成一个chain的是带有affix性质的东西（比如英语中的第三人称单数后缀或者过去时后缀），那么这就会造成所谓“affix lowering”——若最高的一个affix不能附着在任何东西上，那么就spellout次高的，从而看起来就像affix从最高的位置移动到了次高的位置。

# 词类

单纯的N实际上可以看成一个属性词，D则是将一个抽象的名词概念转化为一个有指称的概念的功能语类。