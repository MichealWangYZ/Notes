本文试图给出最简方案中一个相对比较能够凝聚共识的分析框架。

# utterance production

1. 和心智过程直接相关的概念体现为features，它们被Merge运算组装在一起。有些学派，如DM，会认为这些feature来自词库的一部分（比如说DM中的list A），还有一些学派认为这些feature直接来自心智；本文中我们说这些feature直接来自心智；
2. 每发生一次Merge，就会尝试自下而上地实行spellout，后面的spellout覆盖前面的spellout的结果；spellout从词库中取出lexical entry，将lexical entry的树和要spellout的树做对比，如果能够匹配则将要spellout的树替换为lexical entry中的phonetic form。
3. spellout结束后的树被移送到PF中，进行词划界、音系操作等工作

phonetic form严格来说可能是phonological form，它含有的是音位，或者甚至可能还有一些超越音位的信息，比如说一个后缀的PF就可能是-ed，-表示它应该黏附到它之前的某个成分上，即有以下规则：

A-B -> AB

# 句法操作

## 基本操作

Merge可以分成两种：External Merge和Internal Merge（又称Move），后者是从已经组装好的成分中复制一个子树然后用于Merge，也就是Move。
Move包括只涉及一个树的简单Move，即将一个树的某个子树移动到其边缘；也有sideward movement，这个是把一个树的子树移动到另一个树的边缘（然后如果再将两个树Merge起来，那就得到了head movement）。
还有ATB movement，就是两个一样的子树被一起移动到树的边缘，只留下一个。
这实际上可以通过一次sideward movement（形成两个一样的子树）加上一次简单Move（将一个子树移动到边缘）来构造。

Agree运算让feature“扩散”。

Spellout运算遵循以下步骤：将要被spellout的树和词库中的树比对，构成要spelllout的树的超集，但与此同时比要spellout的树多出来的成分最少的树对应的语音形式就是spellout的结果。
也即：

1. 在所有能够被spellout的子树当中，选择最大的子树；
2. 在所有能够spellout该子树的条目中，选择能够完全包含该子树的条目；
3. 在上一步选取的条目中，选择那些含有特征最少的条目。

完全有这样的可能：一个树的子树先被spellout了一次，然后它本身又被spellout了，那么既然后面的结果覆盖前面的结果，我们得出结论：词库中能够匹配要被实现的树的最大的树最终胜出。

如果匹配不到任何lexical entry，那么忽略要spellout的树中已经被spellout的成分（trace也忽略），再次尝试匹配。实际上“已经被spellout的成分”这个概念是有点模糊不清的：它是指字面意义上已经被匹配过、实现过的树，还是已经“定型”，被transfer到PF的树？

以上所有操作都是cyclic的：Merge总是发生在正在被处理的句法树的最外层，Merge完之后就尝试spellout。
总之，同一个树中可能有一些部分正在被Merge建构，有一些部分已经被spellout了。

# 可以被废弃的，但仍然有用的概念

## feature bundle

**feature bundle**是多重head组成的一个复杂树的一种简化写法。

## post syntactic operations

主要是affix lowering和head movement，是不是把这两个东西当成post syntactic operations完全取决于你认为句法可以容忍多少语义无解的东西。

readjustment和context-relevant spellout的概念可以使用适当安排lexical entry来解决。例如对readjustment (doed -> did)，可以认为did是[do + past tense]整体语音实现的结果，那么由于biggest wins，最后正确的形式就是did。
readjustment是spellout过程中自然而然发生的。
context-relevant spellout需要的无非是引入更多的functional head，通过Agree之类的方法捕捉上下文中影响spellout的信息。

但需要注意的是，以上方法都需要假设很多仅仅用于确定形态的functional head，实际上就是AGR insertion的翻版，因此本质上仍然多多少少有点purely morphological的意思。
这就完全是记号的问题了。

## phase

Phase Theory, Angel J.G.

比较麻烦的是phase的概念。

a rule of thumb: uninterpretale features被check的地方就是一个phase head。
如果我们假设，为了避免混乱，被spellout过的成分不再能够发生其它句法操作，那么实际上我们就获得了某种版本的phase：一旦一个成分被spellout并且没有更大的lexical entry可以spellout它，那么它就不再能够发生任何句法操作。

总之，现在我们有两种理论：

- 存在phase，只有当phase head进入推导时，才发生自下而上的spellout；spellout在匹配lexical entry时忽略所有已经被transfer的成分。
- 没有显式的phase概念，被spellout过的成分不再能够发生其它句法操作，那么最大的lexical insertion就构成一个phase；这样实际上到处都是phase，不止C或者v

后一种理论可能产生这样的疑难：既然到处都是phase，那么C或者v有什么特殊的？phase head起到两种作用：一种是避免phase内部再发生Merge，或者phase内部的feature被赋值，而一旦假设spellout过的成分不再发生别的句法操作，这就是显然的；第二是避免phase domain内部的特征扩散到外部去，但是这可以通过让Agree尽可能local来解决。
的确，通过specifier“逃离”phase的情况是确实存在的，但是要逃离的phase并不是phase head触发的。

需要注意的是为了保证外界能够“知道”一个已经spellout了的成分是什么，已经spellout的成分中的特征还是可以扩散出去的，例如已经spellout了的DP也可以导致第三人称单数词尾。

phase的另一个关键点在于限制上下文有关的spellout。看起来，一个代词是被实现为普通代词还是反身代词，主要还是取决于它和先行词是不是在同一个phase内部。
的确，本文使用的spellout算法没有上下文有关的spellout，但是

# 对一些疑难问题的澄清

# 对常见现象的解释

## 形态变体

传统上用readjustment rules解释为什么会有do+ed -> did这一类情况，但是实际上完全可以用biggest wins定理解释它：did整体实现了do+ed而已。

## coreference

可能代词和名词一开始是同一个constituent，后来名词移走，代词留下。
在处理anaphor时，有一种可能是，anaphor有unvalued的指称属性，这个feature必须和某个DP发生Agree才行。这样一开始代词和名词就不是同一个constituent，否则一开始就已经发生Agree了。

## relativization

[<sub>XP</sub> 被提前的名词 [ X [ 从句 ] ] ]

然后也许被提前的是一个DP，也许是NP（从而需要将XP封装进一个DP中）
