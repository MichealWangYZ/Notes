本文试图给出最简方案中一个相对比较能够凝聚共识的分析框架。

# 生成语言学的目的

语法研究大致可以分成四类：

1. 已被证实的
2. 可被证实的
3. 人类可以处理的
4. （在某个非常大的框架内，如type 0 grammar）可被描述的

第一种是已经被明确记录、分析、写下来的语法：英语语法，汉语语法；第二种是我们知道存在但也许尚未调查清楚的，如某个人的特殊遣词造句方式，历史语法；第四种是“脑洞大开”型的，比如说我们可以要求某种语言的词的第质数个音节发生一些变化，或者句子整句颠倒过来表示否定等等。
生成语言学希望能够通过前两种语法获知第三种语法，这就是语法研究的认知取向。

应该指出，大部分人类可以处理的语法实际上都不见得在实际的语言中被证实了。这是很自然的：人类语言大约有6000种，但是所有可能的语法构造排列组合得到的数目恐怕远远多于这个数目。
或者说，生成语言学的理论部分的核心在于“可能的”语法，而不是“比较可能的”语法，后者和心理学、社会学，乃至“某个具有某种奇怪特征的语族正好存活下来了”的意外都有关系，相对复杂。

# utterance production

1. 和心智过程直接相关的概念体现为features，它们被Merge运算组装在一起。有些学派，如DM，会认为这些feature来自词库的一部分（比如说DM中的list A），还有一些学派认为这些feature直接来自心智；本文中我们说这些feature直接来自心智；
2. 每发生一次Merge，就会尝试自下而上地实行spellout，后面的spellout覆盖前面的spellout的结果；spellout从词库中取出lexical entry，将lexical entry的树和要spellout的树做对比，如果能够匹配则将要spellout的树替换为lexical entry中的phonetic form。
3. spellout结束后的树被移送到PF中，进行词划界、音系操作等工作

phonetic form严格来说可能是phonological form，它含有的是音位，或者甚至可能还有一些超越音位的信息，比如说一个后缀的PF就可能是-ed，-表示它应该黏附到它之前的某个成分上，即有以下规则：

A-B -> AB

# 操作

## 基本句法操作

Merge可以分成两种：External Merge和Internal Merge（又称Move），后者是从已经组装好的成分中复制一个子树然后用于Merge，也就是Move。
Move包括只涉及一个树的简单Move，即将一个树的某个子树移动到其边缘；也有sideward movement，这个是把一个树的子树移动到另一个树的边缘（然后如果再将两个树Merge起来，那就得到了head movement）。
还有ATB movement，就是两个一样的子树被一起移动到树的边缘，只留下一个。
这实际上可以通过一次sideward movement（形成两个一样的子树）加上一次简单Move（将一个子树移动到边缘）来构造。

Agree运算让feature“扩散”。

Spellout运算遵循以下步骤：将要被spellout的树和词库中的树比对，构成要spelllout的树的超集，但与此同时比要spellout的树多出来的成分最少的树对应的语音形式就是spellout的结果。
也即：

1. 在所有能够被spellout的子树当中，选择最大的子树；
2. 在所有能够spellout该子树的条目中，选择能够完全包含该子树的条目；
3. 在上一步选取的条目中，选择那些含有特征最少的条目。

完全有这样的可能：一个树的子树先被spellout了一次，然后它本身又被spellout了，那么既然后面的结果覆盖前面的结果，我们得出结论：词库中能够匹配要被实现的树的最大的树最终胜出。

如果匹配不到任何lexical entry，那么忽略要spellout的树中已经被spellout的成分（trace也忽略），再次尝试匹配。实际上“已经被spellout的成分”这个概念是有点模糊不清的：它是指字面意义上已经被匹配过、实现过的树，还是已经“定型”，被transfer到PF的树？

以上所有操作都是cyclic的：Merge总是发生在正在被处理的句法树的最外层，Merge完之后就尝试spellout。
总之，同一个树中可能有一些部分正在被Merge建构，有一些部分已经被spellout了。

# 可以被废弃的，但仍然有用的概念

## feature bundle

**feature bundle**是多重head组成的一个复杂树的一种简化写法。由于本文给出的系统并不区分adjoined head和projection，这种“粗粒化”手段一定是可行的。
我们还将在下面不断看到这种操作。

## selection

类似于“名词选择动词”这种selection现在可以被拆成两部分。一部分直接来自概念-意向系统，一部分来自spellout。
前者的例子不用多说。
后者的例子：有些动词的宾语一定要有某种格，那么如果我们认为具有某种格的动词由一个functional head带出，并且动词只有和这个functional head放在一起时才能够正确地被spellout，那么我们就解释了为什么该动词的宾语一定要具有某种格，或者说为什么这个动词选择具有某种格的名词。

当然，如果我们真的要认为抽象feature带有selector也不是不可以，但是这样就需要一个包含各种抽象feature的抽象词库，句法是从词库投射而来的。
但是实际上不用这个词库也可以得到一样的解释效果。
无论如何，这个真的是notation的问题了。（所以从这个角度，nanosyntax和DM的语法结构其实是统一的，只不过使用的记号不同罢了）

实际上，概念-意向系统的限制也可以理解成spellout的限制：无法正确地语义实现一个句法树，那么它肯定不合法。

## category

像“名词”、“动词”之类的category的作用通常是为selection提供目标（比如说动词应该选择名词，等等）。
但实际上我们也还是可以使用category head和实义词根组合来达到这样的效果，比如说“走”就是verbalizer加上“走”的抽象概念。

然后，有些词总是名词，有些词可以是名词又是动词，还有些词只是动词就可以归结到概念-意向系统上面，比如说verbalizer+“人”没办法语义解释。

## 实义词根和功能语类一样吗？

实义词根通常允许各种活用，而功能语类不允许。不过我们真的把实义词根当成一系列功能语类的组合（比如说"fall"就是“向下运动”，然后可以使用诸如“向下”、“运动”之类的功能语类来组装出它），然后认为概念-意向系统允许将实义词根和category head组装起来，那就解释了各种活用。

当然，单独分出来一个实义词根肯定可以大大简化分析。

## post syntactic operations

主要是affix lowering和head movement，是不是把这两个东西当成post syntactic operations完全取决于你认为句法可以容忍多少语义无解的东西。

readjustment和context-relevant spellout的概念可以使用适当安排lexical entry来解决。例如对readjustment (doed -> did)，可以认为did是[do + past tense]整体语音实现的结果，那么由于biggest wins，最后正确的形式就是did。
readjustment是spellout过程中自然而然发生的。
context-relevant spellout需要的无非是引入更多的functional head，通过Agree之类的方法捕捉上下文中影响spellout的信息。

但需要注意的是，以上方法都需要假设很多仅仅用于确定形态的functional head，实际上就是AGR insertion的翻版，因此本质上仍然多多少少有点purely morphological的意思。
这就完全是记号的问题了。

还有一个是spellout driven movement，我们其实完全可以把这个看成“词的话题化”或者“词的EPP”。当然这样的坏处就是需要增加大量功能语类，并且不同的语言中这些功能语类是不是都存在就很可疑。不过反正句法制图也有类似的问题对吧……

## phase

Phase Theory, Angel J.G.

比较麻烦的是phase的概念。

a rule of thumb: uninterpretale features被check的地方就是一个phase head。
如果我们假设，为了避免混乱，被spellout过的成分不再能够发生其它句法操作，那么实际上我们就获得了某种版本的phase：一旦一个成分被spellout并且没有更大的lexical entry可以spellout它，那么它就不再能够发生任何句法操作。

总之，现在我们有两种理论：

- 存在phase，只有当phase head进入推导时，才发生自下而上的spellout；spellout在匹配lexical entry时忽略所有已经被transfer的成分。
- 没有显式的phase概念，被spellout过的成分不再能够发生其它句法操作，那么最大的lexical insertion就构成一个phase；这样实际上到处都是phase，不止C或者v

后一种理论可能产生这样的疑难：既然到处都是phase，那么C或者v有什么特殊的？phase head起到两种作用：一种是避免phase内部再发生Merge，或者phase内部的feature被赋值，而一旦假设spellout过的成分不再发生别的句法操作，这就是显然的；第二是避免phase domain内部的特征扩散到外部去，但是这可以通过让Agree尽可能local来解决。
的确，通过specifier“逃离”phase的情况是确实存在的，但是要逃离的phase并不是phase head触发的。

需要注意的是为了保证外界能够“知道”一个已经spellout了的成分是什么，已经spellout的成分中的特征还是可以扩散出去的，例如已经spellout了的DP也可以导致第三人称单数词尾。

phase的另一个关键点在于限制上下文有关的spellout。看起来，一个代词是被实现为普通代词还是反身代词，主要还是取决于它和先行词是不是在同一个phase内部。
的确，本文使用的spellout算法没有上下文有关的spellout，但是

# 对一些疑难问题的澄清

# 对常见现象的解释

## 形态变体

传统上用readjustment rules解释为什么会有do+ed -> did这一类情况，但是实际上完全可以用biggest wins定理解释它：did整体实现了do+ed而已。

## coreference

可能代词和名词一开始是同一个constituent，后来名词移走，代词留下。
在处理anaphor时，有一种可能是，anaphor有unvalued的指称属性，这个feature必须和某个DP发生Agree才行。这样一开始代词和名词就不是同一个constituent，否则一开始就已经发生Agree了。

## relativization

[<sub>XP</sub> 被提前的名词 [ X [ 从句 ] ] ]

然后也许被提前的是一个DP，也许是NP（从而需要将XP封装进一个DP中）
