# 归纳构造演算，一阶逻辑及其它

首先我们应该明确一件事：实际上数学并没有一个真的无可置疑的基础。
的确，原则上可以用传统平面几何的方式做微积分计算，甚至可以使用很多我们绝对想不到的体系做数学的基础。
因此，数学基础更多的起到的是“心安”的作用：它用于判断：

1. 我们的哪些推理是可信的；
2. 我们的哪些数学构造可以认为是存在的。（比如说，也许满足皮亚诺公理的对象根本就不存在呢？）

关于前者，一阶逻辑是典范；关于后者，集合论很大程度上就是用来做这件事的。我们研究集合一方面是为了单纯引入“集合”这一概念，一方面是为了做**构造**：表明自然数是可以构造出来的，等等。

然而，集合论在构造这件事上实际上并不自然，只需要简单地看一看自然数在集合论中的繁复定义就可以确信这一点。
实际上，集合论对确保数学对象的存在性这件事的处理是非常ad hoc的：它诉诸了一些“什么样的集合是存在的”的公理，而在实际的数学操作中，我们更希望简单地“写出我们想要的对象的所有性质”，然后检查它是否存在。

此外，集合论+一阶逻辑的表述也没法捕捉下面的事实：映射等概念一而再再而三地出现，而集合论只是简单地将它们编码为元素对；直觉上看，等词在定义中的作用和“当且仅当”是一样的，但是在一阶逻辑中前者是谓词而后者是逻辑运算符；数学证明、命题本身可以被当成数学对象（不是在元语言中），而集合论+一阶逻辑根本处理不了这种东西，而需要非常繁冗的元数学；此外，不少集合论公理和逻辑推导规则实际上是可以互换的，那么更加优美的方案显然应该将这些东西“融为一体”才行。
实际上这也反映了集合论+一阶逻辑的formalism的一个很大的问题，就是要扩展它非常不便。

一种可能的解决方案是引入高阶逻辑，但是实际上这等同于引入了类型论。
还有一种解决方案是使用符号推导系统（如Mathematica），但是首先这就把一阶逻辑当成了某种可以拿来做计算的“表达式”，和常见的句法证明风格很不搭；其次这种approach也可以容易地用构造演算实现。

对引入类型论formalism的一种可能的反驳是：它太“大”了，可以任意地做软件开发、程序验证、证明辅助，而我们只需要一个简单的theorem prover而已！
但是，如果我们局限在传统处理方式中，那么软件开发、程序验证等“额外功能”都需要开发额外的形式系统来处理，又需要撰写大量“接口”性质的定义、定理、证明使得我们能够以一种“数学”的方式处理它们：例如说，我们需要在一阶逻辑加集合论的框架中严格定义程序行为，需要定义一个Hoare逻辑（然后因为prover未必支持扩展一阶逻辑，还需要在FOL prover中弄一些语法糖来把Hoare logic转化为FOL命题），可能还需要很多元数学的论证（结果就是普通的证明和这些元数学论证竟然还不能写在一个文件里面）——但是引入大量元数学本身也是非常“大而无当”的做法，还凭空增加了很多苦力活。
相比之下，能够在一个统一的框架中完成所有这些事情而不需要和元数学打太多交道也许是更好的选择。

从某种意义上，传统的一阶逻辑加集合论就像正则表述，而归纳构造演算以及类似的其它类型论方法就像路径积分表述，前者看起来更加符合直觉、更加“简洁”、可以用于描述后者，然而处理越复杂的问题就越显得力不从心：需要同时考虑的因素实在太多了。
后者一开始看起来缺乏motivation，但是实际上更加便于一般化的处理，并且一旦熟练掌握，工作效率可以大大提高。

需要注意的是在特殊情况下使用FOL可能反而更加方便，例如有很多automated theorem prover in FOL。这就好像很多量子模拟还是会使用哈密顿量那一套东西一个道理。
此时使用FOL当然是最好的。

总之，FOL适合用作形式化理论的“入门理论”，并为其它框架的有效性提供辩护，也适用于一些特殊任务，但是工程化的、scalable的形式化方法，也许CIC之类的typed lambda calculus真的是更好的选择，正如物理中可以从正则表述导出的路径积分表述实际上更适合抓住物理实际无脑算而不必分析tricky的各种细节一样。
路径积分和CIC乍一看让人感觉“有些道理但是不知道在干什么”，但是一旦摸透它的用法——bingo! Everything works out.

当然，是不是真的要引入全套CIC还是一个问题。例如Isabelle就采用了一种理论中立的方法：它本身可以称为一种Weak type theory，但是没什么人会直接拿它写证明，都是引入各种公理之后得到Isabelle/ZF, Isabelle/HOL。实际上在Isabelle/ZF中你并不需要写很多涉及类型的东西，因为一切都封装好了。

# 构造演算

## CoC的定义

CoC中的每一个Judgement都形如$\Gamma \vdash x:A$，即“从一组假设可以推导出$x$属于某个类型”，其中$x$是一个term而$A$是一个类型（类型也是一种特殊的term）。
但是要注意“类型”在这里并不是一种奇怪的集合，而只是一个term的某种标签而已。
实际上，真的做数学证明时我们未必就会频繁地分析“某个term到底是不是属于某个类型”——**命题**并不会被编码为$x:A$的形式。

term包括这么几种：

- $\mathrm{Type}$
- $\mathrm{Prop}$，所有命题都具有此类型；Prop的存在体现了CoC“数学”的一面，很多其它类型系统也可以用来做证明，但是并没有一个显式的Prop
- 变量$x, y, z$等等
- 常量，预先设置好类型和值的一些东西；它和变量的区别在于变量可以参与$\forall$引入，可以被$\forall$约束而常量不行；
- 若$A$和$B$都是term，那么$AB$也是；使用更加通常的记号，$AB$其实是$A(B)$，就是把$A$当成一个函数来调用，$B$是参数
- 若$A$和$B$都是term而$x$是变量，那么$\lambda x:A. B$和$\forall x:A, B$都是term；前者就是普通的带类型的lambda表达式，后者是lambda表达式本身的类型（为什么使用$\forall$符号一会会看到）

---

**注意**

CoC中的变量和编程语言里面那种mutable variables是不一样的，实际上CoC中的常量反而和编程中的variable比较接近；但是CoC中的常量依照定义就是immutable的，需要而且只能被赋值一次。

---

现在来看推导规则：

- Prop本身的类型是Type：
  $$
  \frac{}{\Gamma \vdash \mathrm{Prop}:\mathrm{Type}}
  $$
- 自然演绎逻辑中常见的推导规则，就是可以随意地从已知命题中拿一个出来用：
  $$
  \frac{}{\Gamma, x:A, \Gamma' \vdash x:A}
  $$
- 给$\forall x:A.B$确定类型，$A:K$之类的东西是为了保证确确实实有一个类型$A$（下同）：
  $$
  \frac{\Gamma \vdash A:K, \quad \Gamma, x:A \vdash B:L}{\Gamma \vdash (\forall x:A, B) : L}
  $$
- 给lambda表达式定类型：
  $$
  \frac{\Gamma \vdash A:K, \quad \Gamma, x:A \vdash N:B}{\Gamma \vdash (\lambda x:A.N): (\forall x:A,B)}
  $$
- 给“函数调用”的结果定类型，$x:=N$指的是把$B$中但凡有$x$出现的地方的$x$都换成$N$：
  $$
  \frac{\Gamma \vdash M: (\forall x:A, B), \quad \Gamma \vdash N:A}{\Gamma \vdash MN: B[x:=N]}
  $$
- $\beta$规约不改变类型，所谓$\beta$规约指的是把函数调用算出来，也就是说把$(\lambda x:A.B)(a)$替换成$B[x:=a]$；需要显式引入这个规定是因为上面几条规则只是说了“函数调用的返回值满足如何如何的类型”，但是根本就没有说函数调用实际上是怎么操作的，所以需要专门提一句：
  $$
  \frac{\Gamma \vdash M:A, \quad A =_\beta B, \quad \Gamma \vdash B:K }{\Gamma \vdash M:B}
  $$

## 一阶逻辑

上面的东西看起来非常缺乏动机，所以我们首先来看看，CoC是不是可以容纳一阶逻辑。

我们将看到，类型代表命题，而具有某个类型的term则是这个命题的证明。
（$\forall x:A, B$中的$A$未必代表逻辑命题，它可以只是为了避免“把集合和数乘起来”之类的反直观操作，当然也可以代表逻辑命题）
公理没有证明，因此就是$x:A$这样没有赋予实际值的声明；定理有证明，因此形如$x:A=\cdots$，其值就是证明。
这样，有某个term以之为类型的命题就是真的，或者说，能够被实现的函数签名都是真命题。
从计算的角度，定理是definition而公理是declaration，因为定理需要证明，所以需要被赋予一个实际的值，而公理不需要被证明，只需要声明就可以。

我们首先来看命题逻辑。设类型$A, B, C$等表示逻辑命题，定义

- $A \rightarrow B$定义为$\forall x:A, B$，其中$B$不含$x$

这样的定义合理吗？首先我们容易看出
$$
\frac{\Gamma \vdash A:\mathrm{Prop}, \quad \Gamma \vdash B:\mathrm{Prop}}{\Gamma \vdash (A \rightarrow B): \mathrm{Prop}}.
$$
其次我们来看一看$\rightarrow$引入和消去规则是不是成立。再次提醒，$A$成立指的是能够找到一个term使得$x:A$。
$\rightarrow$引入规则成立，因为如果$A$和$B$都成立，那就有$x:A$且$y:B$，从而lambda表达式$\lambda x:A. y$的类型就是$\forall x:A.B$，从而$A\rightarrow B$可以被证明。
$\rightarrow$消去规则也成立，这是显然的，因为只需要将$A \rightarrow B$的证明当成函数作用在$A$的证明上就可以得到$B$的证明，从而$B$确实成立。
因此以上逻辑蕴涵的定义是合理的。

我们还看到，$A \rightarrow B$的证明实际上就是读入$A$的证明，输出$B$的证明的一个函数，这从另一个角度展现了C-H同构的意义。

逻辑蕴涵定义好之后，我们假定$\rightarrow$为右结合的，并且定义其它逻辑运算符：

- $A \land B$定义为$\forall C:\mathrm{Prop}, (A \rightarrow B \rightarrow C) \rightarrow C$
- $A \lor B$定义为$\forall C:\mathrm{Prop}, (A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow C$
- $\lnot A$定义为$\forall C:\mathrm{Prop}, A \rightarrow C$
- $\exist x:A, B$定义为$\forall C:\mathrm{Prop}, (\forall x:A, B \rightarrow C) \rightarrow C$

所有这些运算符都是特殊的函数：它们读入两个命题，输出一个命题。（和标准的一阶逻辑不同，在CoC中$\forall$的引入和消除规则是自带的，而其余逻辑运算符的引入和消除规则都是构造出来的函数；在这里我们看到了CoC的另一个好处：证明策略——“要证明A只需要证明B”——实际上就是一个读入一个命题而输出另一个命题的函数，从而没有必要使用元语言就能够定义和使用证明策略，大大简化了问题）
在CoC中我们可以很容易地讨论“这个运算符如何如何”，而在纯粹的一阶逻辑中这种讨论只能在元语言中进行。

最后，使用CoC得到的这个一阶逻辑实际上是直觉主义的，因为容易看出没办法得到排中律。
排中律需要作为一条公理被引入——当然，这条公理没有具体的term实现它，这也是可以理解的，因为加上排中律以后可以定义出来图林机没法实现的term（比如各种不可计算数）。

## 编程语言的类型系统

其实没有必要单独把编程语言的类型系统拿出来说，因为既然命题逻辑在CoC中被实现了，那么由C-H同构，自然可以得到一个类型系统。

首先我们有$A \rightarrow B$，这实际上就是将类型$A$的数据映射为类型$B$的一个函数。

实际上，图灵完备的自然演绎风格的typed lambda calculus按照其强度可以组成一个称为lambda cube的结构，而CoC位于其顶端；因此所有typed lambda calculus实际上都是采用不同的方式对CoC略作阉割得到的。

## 规约

CoC既然实际上是一种typed lambda calculus，我们肯定要分析一个term怎么被化简。
实际上如果不引入排中律，CoC里面的term都是保证能够停机的。

我们这里先不详细讨论规约，实际上在本节定义的比较简单的CoC中怎么做term化简是非常显然的。

# CIC used in Coq

## 对CoC的扩展

简单地说，引入了类似于`let ... in`语句之类的东西，需要更多地注重于well-formed-ness.

## tactics和交互式证明

# CIC used in Lean